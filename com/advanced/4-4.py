# -*- coding: utf-8 -*-
# python中初始化实例属性
#
# 虽然我们可以自由地给一个实例绑定各种属性，但是，现实世界中，一种类型的实例应该拥有相同名字的属性。例如，Person类应该在创建的时候就拥有 name、gender 和 birth 属性，怎么办？
#
# 在定义 Person 类时，可以为Person类添加一个特殊的__init__()方法，当创建实例时，__init__()方法被自动调用，我们就能在此为每个实例都统一加上以下属性：
#
# class Person(object):
#     def __init__(self, name, gender, birth):
#         self.name = name
#         self.gender = gender
#         self.birth = birth
#
# __init__() 方法的第一个参数必须是 self（也可以用别的名字，但建议使用习惯用法），后续参数则可以自由指定，和定义函数没有任何区别。
#
# 相应地，创建实例时，就必须要提供除 self 以外的参数：
#
# xiaoming = Person('Xiao Ming', 'Male', '1991-1-1')
# xiaohong = Person('Xiao Hong', 'Female', '1992-2-2')
#
# 有了__init__()方法，每个Person实例在创建时，都会有 name、gender 和 birth 这3个属性，并且，被赋予不同的属性值，访问属性使用.操作符：
#
# print xiaoming.name
# # 输出 'Xiao Ming'
# print xiaohong.birth
# # 输出 '1992-2-2'
#
# 要特别注意的是，初学者定义__init__()方法常常忘记了 self 参数：
#
# >>> class Person(object):
# ...     def __init__(name, gender, birth):
# ...         pass
# ...
# >>> xiaoming = Person('Xiao Ming', 'Male', '1990-1-1')
# Traceback (most recent call last):
#   File "<stdin>", line 1, in <module>
# TypeError: __init__() takes exactly 3 arguments (4 given)
#
# 这会导致创建失败或运行不正常，因为第一个参数name被Python解释器传入了实例的引用，从而导致整个方法的调用参数位置全部没有对上。
# 任务
#
# 请定义Person类的__init__方法，除了接受 name、gender 和 birth 外，还可接受任意关键字参数，并把他们都作为属性赋值给实例。


class Person(object):
    def __init__(self, name, gender, birth, **kw):
        self.name = name
        self.gender = gender
        self.birth = birth
        for k, v in kw.iteritems():
            setattr(self, k, v)


xiaoming = Person('Xiao Ming', 'Male', '1990-1-1', job='Student')
print xiaoming.name
print xiaoming.job
